<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Agentic TotChef: Architetture software, Patterns, and Best Practices | It&#39;s worth a Coke</title>
<meta name="keywords" content="AI, GenAI, Agent, Ollama, Python">
<meta name="description" content="L&#39;articolo esplora l&#39;architettura software, i design pattern e le best practice per progettare agenti AI scalabili e manutenibili, utilizzando un caso di studio chiamato &#39;TotChef&#39; che genera menù settimanali per una bambina di 1 anno.">
<meta name="author" content="carmelolg">
<link rel="canonical" href="https://carmelolg.github.io/it-is-worth-a-coke/posts/ai-agentic-flow-architecture/ai-agentic-flow-architecture_italian/">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-PEC7RY0337"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PEC7RY0337');
</script>

<meta name="google-site-verification" content="G-PEC7RY0337">
<link crossorigin="anonymous" href="/it-is-worth-a-coke/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css" integrity="sha256-2jIR5e&#43;Ge/K3X9WmUVz&#43;1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://carmelolg.github.io/it-is-worth-a-coke/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://carmelolg.github.io/it-is-worth-a-coke/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://carmelolg.github.io/it-is-worth-a-coke/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://carmelolg.github.io/it-is-worth-a-coke/apple-touch-icon.png">
<link rel="mask-icon" href="https://carmelolg.github.io/it-is-worth-a-coke/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://carmelolg.github.io/it-is-worth-a-coke/posts/ai-agentic-flow-architecture/ai-agentic-flow-architecture_italian/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://carmelolg.github.io/it-is-worth-a-coke/posts/ai-agentic-flow-architecture/ai-agentic-flow-architecture_italian/">
  <meta property="og:site_name" content="It&#39;s worth a Coke">
  <meta property="og:title" content="Agentic TotChef: Architetture software, Patterns, and Best Practices">
  <meta property="og:description" content="L&#39;articolo esplora l&#39;architettura software, i design pattern e le best practice per progettare agenti AI scalabili e manutenibili, utilizzando un caso di studio chiamato &#39;TotChef&#39; che genera menù settimanali per una bambina di 1 anno.">
  <meta property="og:locale" content="en-EN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-02-16T00:00:00+00:00">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="GenAI">
    <meta property="article:tag" content="Agent">
    <meta property="article:tag" content="Ollama">
    <meta property="article:tag" content="Python">
      <meta property="og:image" content="https://carmelolg.github.io/it-is-worth-a-coke/images/Tokio.jpeg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://carmelolg.github.io/it-is-worth-a-coke/images/Tokio.jpeg">
<meta name="twitter:title" content="Agentic TotChef: Architetture software, Patterns, and Best Practices">
<meta name="twitter:description" content="L&#39;articolo esplora l&#39;architettura software, i design pattern e le best practice per progettare agenti AI scalabili e manutenibili, utilizzando un caso di studio chiamato &#39;TotChef&#39; che genera menù settimanali per una bambina di 1 anno.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://carmelolg.github.io/it-is-worth-a-coke/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Agentic TotChef: Architetture software, Patterns, and Best Practices",
      "item": "https://carmelolg.github.io/it-is-worth-a-coke/posts/ai-agentic-flow-architecture/ai-agentic-flow-architecture_italian/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Agentic TotChef: Architetture software, Patterns, and Best Practices",
  "name": "Agentic TotChef: Architetture software, Patterns, and Best Practices",
  "description": "L'articolo esplora l'architettura software, i design pattern e le best practice per progettare agenti AI scalabili e manutenibili, utilizzando un caso di studio chiamato 'TotChef' che genera menù settimanali per una bambina di 1 anno.",
  "keywords": [
    "AI", "GenAI", "Agent", "Ollama", "Python"
  ],
  "articleBody": " Introduzione Lo sviluppo di codice sorgente coadiuvato da sistemi di intelligenza artificiale è ormai in crescita esponenziale. Le capacità degli LLM forniti da vari provider consentono, anche in modalità Zero-Shot Learning, di generare codice sorgente di qualità con un livello di astrazione e complessità elevato. I risultati, che ritengo sorprendenti, arrivano dall’utilizzo dei cosiddetti Agent AI (in modalità ReAct e aiutati da Server MCP), migliorando la produttività degli sviluppatori.\nMa fermiamoci un attimo. Mentre il mondo è coperto di entusiasmo e aspettative, è importante ricordare che la generazione di codice sorgente da parte di un LLM (in modalità agentica e non) è solo una parte del processo di sviluppo software. La richiesta di Software Architect è destinata a rimanere alta per scongiurare il rischio di creare software che, seppur funzionante, sia poco performante, difficile da mantenere, scalare ed estendere.\nA tutti noi è capitato di partecipare a progetti software che, seppur funzionanti, avevano un debito tecnico enorme e difficile da contenere. Il tempo e i costi spesso hanno influenzato negativamente la qualità del software, portando a soluzioni quick and dirty che, sebbene risolvessero il problema immediato, aumentavano le percentuali di codice sorgente non performante e a volte anche esposto a vulnerabilità.\nLa domanda è: in una fase in cui le tecnologie stanno evolvendo rapidamente, possiamo permetterci ancora una volta lo stesso errore?\nLa risposta deve essere no, anche perché, oltre al debito tecnico, in questo caso ci sono dei costi attivi (provider di servizi AI, DB vettoriali, …) da considerare non indifferenti.\nUtilizzando agenti AI senza una solida base di progettazione software, si corre il rischio di andare a braccio progettando sistemi che funzionano, ma che non sono scalabili e manutenibili. Tra i rischi troviamo:\n“over-engineering”, ovvero progettare sistemi troppo complessi per risolvere problemi semplici, con conseguente aumento dei costi attivi del progetto. performance inadeguate dovute ad una progettazione non ottimale degli Agent AI, che potrebbe portare a tempi di risposta più lunghi e a un’esperienza utente insoddisfacente. Obiettivo Con questo articolo condividerò un esercizio eseguito con lo scopo di provare alcuni agent design pattern. L’esercizio si basa su un piccolo software d’esempio chiamato Agentic TotChef, che si pone come obiettivo la generazione di un menù settimanale per una bambina di 1 anno tenendo conto di ciò che mangia all’asilo nido, dal ricettario di famiglia e da ciò che è disponibile in casa.\nL’esercizio mi ha aiutato a capire limiti e vantaggi tra cui:\nL’utlizzo di SLM (Small Language Model) in modo da contenere i costi ed ottenere risultati soddisfacenti L’adozione di design pattern e best pratice per progettare agenti AI con un buon grado di performance Small Language Model: limiti e vantaggi Se è vero che i grandi modelli linguistici (LLM) come GPT-5, Gemini, Claude, Grok e simili offrono capacità straordinarie, è altrettanto vero che i Small Language Model (SLM) stanno guadagnando terreno grazie alla loro efficienza e costi ridotti.\nI SLM, come quelli offerti da Ollama, sono progettati per essere più leggeri e meno costosi, rendendoli ideali per applicazioni specifiche che non richiedono la potenza di un LLM completo.\nTra i vantaggi:\nCosti ridotti: I SLM sono generalmente più economici da utilizzare rispetto agli LLM, rendendoli accessibili anche per progetti con budget limitati. Efficienza: I SLM possono essere più veloci nel generare risposte, soprattutto quando si tratta di compiti specifici che non richiedono una comprensione profonda del contesto. Personalizzazione: Con l’aggiunta di un contesto specifico è possibile ottenere risultati più pertinenti e accurati, sfruttando al meglio le capacità del SLM. Tuttavia, è importante riconoscere i limiti dei SLM, come la capacità di comprendere contesti complessi o di generare risposte creative. Quindi la scelta tra LLM e SLM dipende dalle esigenze specifiche del progetto e dagli obiettivi che si vogliono raggiungere.\nNel mio caso, per il progetto TotChef, ho optato per qwen3-8b, che si è dimostrato sufficiente per generare menù settimanali accurati e pertinenti. Ovviamente parliamo di requisiti di complessità medio-bassi e hardware limitato. In ogni caso quanto basta per arrivare ad un risultato soddisfacente con tempi di risposta accettabili.\nAgentic Design Patterns: un approccio per progettare agenti AI scalabili e manutenibili TotChef: Architettura software Conclusioni ",
  "wordCount" : "687",
  "inLanguage": "en",
  "image": "https://carmelolg.github.io/it-is-worth-a-coke/images/Tokio.jpeg","datePublished": "2026-02-16T00:00:00Z",
  "dateModified": "2026-02-16T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "carmelolg"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://carmelolg.github.io/it-is-worth-a-coke/posts/ai-agentic-flow-architecture/ai-agentic-flow-architecture_italian/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "It's worth a Coke",
    "logo": {
      "@type": "ImageObject",
      "url": "https://carmelolg.github.io/it-is-worth-a-coke/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://carmelolg.github.io/it-is-worth-a-coke/" accesskey="h" title="It&#39;s worth a Coke (Alt + H)">It&#39;s worth a Coke</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://carmelolg.github.io/it-is-worth-a-coke/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://carmelolg.github.io/it-is-worth-a-coke/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://carmelolg.github.io/it-is-worth-a-coke/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://carmelolg.github.io/" title="Who I am">
                    <span>Who I am</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Agentic TotChef: Architetture software, Patterns, and Best Practices
    </h1>
    <div class="post-description">
      L&#39;articolo esplora l&#39;architettura software, i design pattern e le best practice per progettare agenti AI scalabili e manutenibili, utilizzando un caso di studio chiamato &#39;TotChef&#39; che genera menù settimanali per una bambina di 1 anno.
    </div>
    <div class="post-meta"><span title='2026-02-16 00:00:00 +0000 UTC'>February 16, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>carmelolg</span>

</div>
  </header> 
  <div class="post-content"><!-- Durante una sessione di lettura intensiva mi sono imbattuto su un libro molto interessante: Agentic Design Pattern di Antonio Gulli, Eng Director in Google. -->
<h1 id="introduzione">Introduzione<a hidden class="anchor" aria-hidden="true" href="#introduzione">#</a></h1>
<p>Lo sviluppo di codice sorgente coadiuvato da sistemi di intelligenza artificiale è ormai in crescita esponenziale.
Le capacità degli LLM forniti da vari provider consentono, anche in modalità <a href="https://www.promptingguide.ai/techniques/zeroshot">Zero-Shot Learning</a>, di generare codice sorgente di qualità con un livello di astrazione e complessità elevato.
I risultati, che ritengo sorprendenti, arrivano dall&rsquo;utilizzo dei cosiddetti <strong>Agent AI</strong> (in modalità <a href="https://www.promptingguide.ai/techniques/react">ReAct</a> e aiutati da <a href="https://modelcontextprotocol.io/docs/getting-started/intro">Server MCP</a>), migliorando la produttività degli sviluppatori.</p>
<p>Ma fermiamoci un attimo. Mentre il mondo è coperto di entusiasmo e aspettative, è importante ricordare che la generazione di codice sorgente da parte di un LLM (in modalità agentica e non)
<strong>è solo una parte del processo di sviluppo software</strong>. La richiesta di Software Architect è destinata a rimanere alta per scongiurare il rischio di creare software
che, seppur funzionante, sia poco performante, difficile da mantenere, scalare ed estendere.</p>
<p>A tutti noi è capitato di partecipare a progetti software che, seppur funzionanti, avevano un debito tecnico enorme e difficile da contenere.
Il tempo e i costi spesso hanno influenzato negativamente la qualità del software, portando a soluzioni <em>quick and dirty</em> che, sebbene risolvessero il problema immediato,
aumentavano le percentuali di codice sorgente non performante e a volte anche esposto a vulnerabilità.</p>
<p><strong>La domanda è: in una fase in cui le tecnologie stanno evolvendo rapidamente, possiamo permetterci ancora una volta lo stesso errore?</strong></p>
<p><strong>La risposta deve essere no</strong>, anche perché, oltre al debito tecnico, in questo caso ci sono dei costi attivi (provider di servizi AI, DB vettoriali, &hellip;) da considerare non indifferenti.</p>
<p>Utilizzando agenti AI senza una solida base di progettazione software, si corre il rischio di andare a braccio progettando sistemi che funzionano, ma che non sono scalabili e manutenibili.
Tra i rischi troviamo:</p>
<ul>
<li>&ldquo;over-engineering&rdquo;, ovvero progettare sistemi troppo complessi per risolvere problemi semplici, con conseguente aumento dei costi attivi del progetto.</li>
<li>performance inadeguate dovute ad una progettazione non ottimale degli Agent AI, che potrebbe portare a tempi di risposta più lunghi e a un&rsquo;esperienza utente insoddisfacente.</li>
</ul>
<h1 id="obiettivo">Obiettivo<a hidden class="anchor" aria-hidden="true" href="#obiettivo">#</a></h1>
<p>Con questo articolo condividerò un esercizio eseguito con lo scopo di provare alcuni <em>agent design pattern</em>.
L&rsquo;esercizio si basa su un piccolo software d&rsquo;esempio chiamato <strong>Agentic TotChef</strong>, che si pone come obiettivo la generazione
di un menù settimanale per una bambina di 1 anno tenendo conto di ciò che mangia all&rsquo;asilo nido, dal ricettario di famiglia e da ciò che è disponibile in casa.</p>
<p>L&rsquo;esercizio mi ha aiutato a capire limiti e vantaggi tra cui:</p>
<ul>
<li>L&rsquo;utlizzo di SLM (Small Language Model) in modo da contenere i costi ed ottenere risultati soddisfacenti</li>
<li>L&rsquo;adozione di design pattern e best pratice per progettare agenti AI con un buon grado di performance</li>
</ul>
<h1 id="small-language-model-limiti-e-vantaggi">Small Language Model: limiti e vantaggi<a hidden class="anchor" aria-hidden="true" href="#small-language-model-limiti-e-vantaggi">#</a></h1>
<p>Se è vero che i grandi modelli linguistici (LLM) come GPT-5, Gemini, Claude, Grok e simili offrono capacità straordinarie,
è altrettanto vero che i Small Language Model (SLM) stanno guadagnando terreno grazie alla loro efficienza e costi ridotti.</p>
<p>I SLM, come quelli offerti da Ollama, sono progettati per essere più leggeri e meno costosi, rendendoli ideali per applicazioni specifiche
che non richiedono la potenza di un LLM completo.</p>
<p>Tra i vantaggi:</p>
<ul>
<li><strong>Costi ridotti</strong>: I SLM sono generalmente più economici da utilizzare rispetto agli LLM, rendendoli accessibili anche per progetti con budget limitati.</li>
<li><strong>Efficienza</strong>: I SLM possono essere più veloci nel generare risposte, soprattutto quando si tratta di compiti specifici che non richiedono una comprensione profonda del contesto.</li>
<li><strong>Personalizzazione</strong>: Con l&rsquo;aggiunta di un contesto specifico è possibile ottenere risultati più pertinenti e accurati, sfruttando al meglio le capacità del SLM.</li>
</ul>
<p>Tuttavia, è importante riconoscere i limiti dei SLM, come la capacità di comprendere contesti complessi o di generare risposte creative.
Quindi la scelta tra LLM e SLM dipende dalle esigenze specifiche del progetto e dagli obiettivi che si vogliono raggiungere.</p>
<p>Nel mio caso, per il progetto TotChef, ho optato per <strong>qwen3-8b</strong>, che si è dimostrato sufficiente per generare menù settimanali accurati e pertinenti.
Ovviamente parliamo di requisiti di complessità medio-bassi e hardware limitato.
In ogni caso quanto basta per arrivare ad un risultato soddisfacente con tempi di risposta accettabili.</p>
<h1 id="agentic-design-patterns-un-approccio-per-progettare-agenti-ai-scalabili-e-manutenibili">Agentic Design Patterns: un approccio per progettare agenti AI scalabili e manutenibili<a hidden class="anchor" aria-hidden="true" href="#agentic-design-patterns-un-approccio-per-progettare-agenti-ai-scalabili-e-manutenibili">#</a></h1>
<h1 id="totchef-architettura-software">TotChef: Architettura software<a hidden class="anchor" aria-hidden="true" href="#totchef-architettura-software">#</a></h1>
<p><img alt="Agentic TotChefArchitecture" loading="lazy" src="../totchef-arch.png"></p>
<h1 id="conclusioni">Conclusioni<a hidden class="anchor" aria-hidden="true" href="#conclusioni">#</a></h1>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://carmelolg.github.io/it-is-worth-a-coke/tags/ai/">AI</a></li>
      <li><a href="https://carmelolg.github.io/it-is-worth-a-coke/tags/genai/">GenAI</a></li>
      <li><a href="https://carmelolg.github.io/it-is-worth-a-coke/tags/agent/">Agent</a></li>
      <li><a href="https://carmelolg.github.io/it-is-worth-a-coke/tags/ollama/">Ollama</a></li>
      <li><a href="https://carmelolg.github.io/it-is-worth-a-coke/tags/python/">Python</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://carmelolg.github.io/it-is-worth-a-coke/posts/ai-agentic-flow-architecture/ai-agentic-flow-architecture_english/">
    <span class="title">Next »</span>
    <br>
    <span>Agentic TotChef: Software Architectures, Patterns, and Best Practices</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://carmelolg.github.io/">carmelolg</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
